<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tech Murmurs</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;600&display=swap" rel="stylesheet">

  <!-- Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <!-- Mermaid (for methodology diagrams) -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>

  <style>
    :root {
      --bg:#0b0e14;
      --panel:#121826;
      --border:#1f2937;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#38bdf8;

      --easy:#4ade80;
      --medium:#facc15;
      --hard:#f87171;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: Inter, system-ui, sans-serif;
      color: var(--text);
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0 1px, transparent 1px 80px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.02) 0 1px, transparent 1px 80px),
        var(--bg);
    }

    header {
      max-width: 1100px;
      margin: auto;
      padding: 4rem 2rem 2.5rem;
    }

    h1 {
      font-family: "Space Grotesk", sans-serif;
      font-size: 3.2rem;
      margin-bottom: 0.3rem;
      letter-spacing: -0.02em;
    }

    .motto {
      font-family: "Space Grotesk", sans-serif;
      font-size: 0.95rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 1.5rem;
    }

    header p {
      max-width: 820px;
      line-height: 1.7;
      color: var(--muted);
      margin-bottom: 1.2rem;
    }

    .top-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-top: 1.8rem;
    }

    .nav {
      display: flex;
      gap: 0.8rem;
    }

    .nav a, .nav button {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      border-radius: 10px;
      padding: 0.45rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      text-decoration: none;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.7rem;
      color: var(--muted);
    }

    .legend-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #6b7280;
      margin-right: 0.25rem;
    }

    .legend-pill {
      position: relative;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      font-weight: 600;
      color: #020617;
      cursor: default;
    }

    .legend-pill.easy { background: var(--easy); }
    .legend-pill.medium { background: var(--medium); }
    .legend-pill.hard { background: var(--hard); }

    .legend-pill::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: -2.2rem;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 0.35rem 0.55rem;
      border-radius: 6px;
      font-size: 0.65rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 20;
    }

    .legend-pill:hover::after {
      opacity: 1;
    }

    main {
      max-width: 1100px;
      margin: auto;
      padding: 0 2rem 4rem;
    }

    .banner {
      background: rgba(74,222,128,0.1);
      border: 1px solid rgba(74,222,128,0.3);
      color: #a7f3d0;
      border-radius: 14px;
      padding: 0.9rem 1.2rem;
      margin-bottom: 2rem;
      font-size: 0.85rem;
    }

    .day-label {
      font-family: "Space Grotesk", sans-serif;
      font-size: 1.1rem;
      margin-bottom: 1.8rem;
      color: var(--text);
    }

    .quest {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 2rem;
    }

    .quest h2 {
      font-family: "Space Grotesk", sans-serif;
      margin: 0.3rem 0 1rem;
    }

    .section {
      margin-bottom: 1.1rem;
    }

    .section-title {
      font-size: 0.75rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #6b7280;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.35rem;
    }

    .meta {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      margin-top: 1.4rem;
      flex-wrap: wrap;
    }

    .difficulty {
      font-size: 0.7rem;
      font-weight: 600;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      color: #020617;
    }

    .easy { background: var(--easy); }
    .medium { background: var(--medium); }
    .hard { background: var(--hard); }

    .build-button {
      background: rgba(56, 189, 248, 0.15);
      border: 1px solid rgba(56, 189, 248, 0.3);
      color: var(--accent);
      padding: 0.5rem 1rem;
      border-radius: 10px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      transition: all 0.2s ease;
      font-family: inherit;
      font-weight: 500;
      margin-left: auto;
    }

    .build-button:hover {
      background: rgba(56, 189, 248, 0.25);
      border-color: rgba(56, 189, 248, 0.5);
      transform: translateY(-1px);
    }

    .copy-button {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.6rem 1.2rem;
      border-radius: 10px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.2s ease;
      font-family: inherit;
      font-weight: 500;
    }

    .copy-button:hover {
      background: rgba(255,255,255,0.05);
      transform: translateY(-1px);
    }

    .prompt-content {
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      line-height: 1.7;
      max-height: 60vh;
      overflow-y: auto;
    }

    .prompt-content h2,
    .prompt-content h3,
    .prompt-content h4 {
      font-family: "Space Grotesk", sans-serif;
      color: var(--text);
    }

    .prompt-content ul {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }

    .prompt-content code {
      font-family: 'Courier New', monospace;
    }

    .loader {
      border: 3px solid var(--border);
      border-top: 3px solid var(--accent);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    footer {
      border-top: 1px solid var(--border);
      padding: 2rem;
      text-align: center;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .footer-inner {
      max-width: 1100px;
      margin: auto;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(8px);
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 2.5rem;
      max-width: 850px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .modal-content h2 {
      font-family: "Space Grotesk", sans-serif;
      margin-top: 0;
    }

    .modal-content h3 {
      font-family: "Space Grotesk", sans-serif;
      margin-top: 2rem;
      font-size: 1.15rem;
    }

    .modal-content p {
      line-height: 1.7;
      color: var(--muted);
      margin-bottom: 1rem;
    }

    .modal-content ul {
      line-height: 1.7;
      color: var(--muted);
      margin-bottom: 1rem;
    }

    .close-x {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      font-size: 1.8rem;
      cursor: pointer;
      color: var(--muted);
      line-height: 1;
      transition: color 0.2s;
    }

    .close-x:hover {
      color: var(--text);
    }

    .modal-content .section {
      border-left: 2px solid var(--border);
      padding-left: 1.4rem;
      margin-top: 1.5rem;
    }

    .modal-content .diagram-wrap {
      margin: 1.5rem 0 2rem;
      background: #0d1018;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.2rem 1rem;
      overflow-x: auto;
    }

    .modal-content .diagram-label {
      font-size: .75rem;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: .75rem;
    }

    .modal-content .diagram-wrap .mermaid svg {
      display: block;
      margin: 0 auto;
      max-width: 100%;
    }

    @media (max-width: 640px) {
      h1 { font-size: 2.2rem; }
      .motto { font-size: 0.8rem; }
      .modal-content { padding: 2rem 1.5rem; }
      .top-row { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>

<header>
  <h1>Tech Murmurs</h1>
  <div class="motto">Independent Builder Intelligence</div>

  <p>
    Side-quest ideas that blend thoughtful indie hacker prompts, early-stage product opportunities, 
    and playful creative experiments. Each idea is generated from live signals in the builder ecosystem â€” GitHub issues, 
    hackathon themes, protocol updates, and developer conversations â€” then synthesized by AI into buildable, vibe-coder-friendly 
    projects you can actually ship.
  </p>

  <p>
    This isn't a trend aggregator or hype tracker. It's a daily snapshot of unfinished ideas, creative 
    experiments hiding in plain sight â€” ideas waiting for someone to care enough to ship them.
  </p>

  <div class="top-row">
    <div class="nav">
      <a href="archive.html"><i data-lucide="archive"></i> Archive</a>
      <button onclick="toggleMethodology()"><i data-lucide="book-open"></i> Methodology</button>
    </div>

    <div class="legend">
      <span class="legend-label">Legend</span>
      <span class="legend-pill easy" data-tooltip="Quick build, low lift, vibe-coder friendly">Easy</span>
      <span class="legend-pill medium" data-tooltip="Scoped side project, some moving parts">Medium</span>
      <span class="legend-pill hard" data-tooltip="Deep rabbit hole, exploratory or research-heavy">Hard</span>
    </div>
  </div>
</header>

<main>
  <div class="banner">Live editorial signals detected.</div>
  <div class="day-label">Daily Drop</div>
  <div id="ideas"></div>
</main>

<footer>
  <div class="footer-inner">
    <div>Built quietly, shipped deliberately.</div>
    <div>Â© 2026 Brookhart Labs</div>
  </div>
</footer>


<!-- METHODOLOGY MODAL -->
<div class="modal" id="methodology" onclick="toggleMethodology()">
  <div class="modal-content" onclick="event.stopPropagation()" style="max-width:860px;">
    <div class="close-x" onclick="toggleMethodology()">âœ•</div>

    <h2>What The Generator Does</h2>

    <p>Tech Murmurs is an AI-powered ideation system designed to surface small, buildable opportunities from public builder activity. It listens for early signals â€” ideas that are being discussed, hinted at, or partially articulated in the wild â€” before they harden into roadmaps, products, or dominant narratives.</p>
    <p>The system draws from places where builders naturally express intent: open-source issue threads, hackathon prompts, protocol updates, and public developer conversations. These sources are chosen not for volume, but for proximity to real, unfinished work.</p>
    <p>Rather than treating every signal as equally meaningful, Tech Murmurs looks for specific expressions of friction, absence, or creative possibility. Language such as "missing," "wish there was," "no tool for," recurring feature requests, or experimental ideas are treated as higher-signal than general commentary. Vague or purely speculative input is intentionally filtered out.</p>
    <p>Each day, collected signals are synthesized by AI into five distinct "side quests" â€” small, concrete project ideas designed for indie builders, vibe coders, and creative experimenters. These aren't market opportunities or startup ideas; they're weekend builds, playful tools, and thoughtful prompts that blend practical utility with creative exploration.</p>
    <p>The AI generation process emphasizes three overlapping categories:</p>
    <ul>
      <li><strong>Thoughtful indie hacker / solo builder prompts (40% weight)</strong> â€” Tools and workflows that make individual building more delightful, efficient, or expressive.</li>
      <li><strong>Early-stage product opportunities (20% weight)</strong> â€” Nascent gaps where a focused tool could provide real value without becoming a platform.</li>
      <li><strong>Creative experiments &amp; playful tools (40% weight)</strong> â€” Whimsical, aesthetic, or exploratory projects that prioritize curiosity and vibes over immediate utility.</li>
    </ul>
    <p>Tech Murmurs publishes ideas as a daily snapshot rather than a continuous feed. A fixed daily set preserves context, avoids recency bias, and creates a historical archive that reveals how certain needs emerge, persist, fade, or recur over time.</p>
    <p>When live sources are temporarily unavailable, the system falls back to a curated baseline of representative ideas. This ensures continuity while making the system's state explicit to the reader.</p>
    <p>Tech Murmurs does not attempt to evaluate market size, adoption likelihood, commercial viability, or technical feasibility. It is not a recommendation engine. Its role is to make early, often-quiet signals visible â€” and to transform them into prompts that feel worth exploring.</p>
    <p>All inputs are public. Attribution is preserved through outbound links, and no private or user-restricted data is accessed.</p>

    <h2>How The Generator Works <span style="color:var(--muted);font-size:.85em;">(For Transparency)</span></h2>
    <p>The sections below describe how the system operates at a technical level. They are included for transparency and auditability, not as a prerequisite for using the tool.</p>

    <div class="section">
      <h3>System Architecture</h3>
      <p>Tech Murmurs is a client-rendered web application backed by serverless ingestion and generation functions. Data collection is performed via Netlify Functions, which proxy public APIs and feeds. AI synthesis happens server-side to protect API credentials and ensure consistent prompt engineering.</p>
    </div>

    <div class="section">
      <h3>Integrated Data Sources</h3>
      <p>Current integrations include the GitHub Search API (for open issues and repository activity), GitHub Releases (used as proxies for protocol roadmaps), public hackathon feeds accessed via RSS, and lightweight article ingestion from developer blogs. Each source is queried independently and normalized into a common signal structure before being passed to the AI synthesis layer.</p>
      <p>Sources are treated as complementary rather than authoritative. No single platform is assumed to represent the full landscape of builder intent. The system prioritizes diversity of input over depth from any one source.</p>
    </div>

    <div class="section">
      <h3>Signal Collection &amp; Filtering</h3>
      <p>During ingestion, Tech Murmurs applies lightweight language analysis to distinguish actionable signals from general discussion. Incoming text is scanned for intent-bearing phrases such as:</p>
      <ul>
        <li>"missing" or "lacking"</li>
        <li>"wish there was" or "it would be great if"</li>
        <li>"no tool for" or "hard to" or "difficult to"</li>
        <li>"what if" or "imagine if" (indicating creative exploration)</li>
        <li>repeated feature requests across issues or discussions</li>
      </ul>
      <p>These are heuristic markers, not definitive signals. The system also considers contextual signals: whether the need appears in a problem description, recurs across sources, is specific enough to suggest a build, or carries a tone of playfulness or curiosity. Text that is vague or purely opinion-based is intentionally deprioritized.</p>
    </div>

    <div class="section">
      <h3>AI Synthesis Pipeline</h3>
      <p>Once signals pass initial filtering, they are sent to an AI language model for creative synthesis. The AI transforms raw signals into five distinct side-quest ideas balancing practical utility, creative experimentation, and playful exploration.</p>
      <p>The prompt engineering emphasizes conversational tone, specificity without intimidation, diversity of type (40% tools / 20% product opportunities / 40% experiments), and vibe-coder friendliness. Each idea includes a title, murmur (why it exists), quest (what to build), worth (three reasons), difficulty, and source links.</p>
      <p>If AI generation fails, the system falls back to a curated set of representative ideas that match the intended tone and scope.</p>
    </div>

    <div class="section">
      <h3>Let's Build! Feature</h3>
      <p>Each idea card includes a "Let's Build!" button that generates a detailed, AI-powered build prompt on demand via Google Gemini, with difficulty-adjusted instructions â€” beginner-friendly for Easy, architecture-focused for Medium, and tradeoff-heavy for Hard. The resulting prompt can be pasted directly into any AI assistant to begin building.</p>
    </div>

    <div class="section">
      <h3>Snapshot &amp; Archival Logic</h3>
      <p>Tech Murmurs publishes a fixed daily snapshot rather than a continuously updating feed. This reduces noise, avoids recency bias, and creates a time-series archive that can be reviewed longitudinally to observe how needs persist, evolve, or disappear over time.</p>
    </div>

    <div class="section">
      <h3>Failure Modes &amp; Fallbacks</h3>
      <p>If live data sources fail, the system enters Sample Data Mode, showing representative ideas while surfacing the system state in the interface banner. If AI generation fails completely, a curated set of high-quality ideas is shown to ensure continuity.</p>
    </div>

    <div class="section">
      <h3>Prompt Engineering Philosophy</h3>
      <ul>
        <li><strong>Playfulness over seriousness</strong> â€” Ideas should feel like side quests, not job assignments</li>
        <li><strong>Experimentation over optimization</strong> â€” Curiosity and creative expression take priority over market fit</li>
        <li><strong>Specificity over abstraction</strong> â€” Concrete projects over vague concepts</li>
        <li><strong>Solo builder scale</strong> â€” Weekend builds, not startup roadmaps</li>
        <li><strong>Human voice</strong> â€” Conversational tone that feels like talking to a friend, not reading marketing copy</li>
      </ul>
    </div>

    <div class="section">
      <h3>Evolution &amp; Iteration</h3>
      <p>Tech Murmurs is an evolving system. Signal sources, filtering heuristics, AI prompts, and synthesis strategies may change over time. Changes that materially affect how ideas are generated will be documented here. The archive serves as both a historical record and a feedback mechanism.</p>
    </div>

    <h2>How It All Fits Together</h2>
    <p>Tech Murmurs runs on two separate tracks: a <strong>scheduled overnight pipeline</strong> that produces each day's quests automatically, and an <strong>on-demand path</strong> that fires whenever you click "Let's Build!" Both tracks are serverless.</p>

    <div class="section">
      <h3>The Overnight Pipeline</h3>
      <p>Every night at 5:01 AM UTC, a pg_cron job fires an authenticated HTTP request to a Netlify function. That function checks whether quests already exist for today (idempotency guard), then fetches live signals from GitHub and developer article feeds in parallel, calls <strong>Anthropic Claude Sonnet</strong> to generate five grounded ideas, and stores the results in Supabase. If sources fail, generation continues with whatever is available. If Claude is unavailable, pre-written fallback ideas are used so the site is never empty.</p>
      <h3>The On-Demand Path</h3>
      <p>When you click "Let's Build!" your browser sends the quest details to a separate Netlify function, which builds a difficulty-adjusted prompt and sends it to <strong>Google Gemini 2.5 Flash</strong>. If Gemini times out (45s) or hits a rate limit, a clear error is returned. Claude handles creative divergent ideation informed by live signals; Gemini handles convergent, practical how-to-build guidance.</p>
    </div>

    <h2>System Flow</h2>
    <p>The diagrams below show how data and requests move through the system end-to-end.</p>

    <div class="diagram-wrap">
      <div class="diagram-label">Daily Generation Pipeline</div>
      <div class="mermaid">
sequenceDiagram
    participant C as pg_cron
    participant N as Netlify Function
    participant G as GitHub API
    participant A as Dev.to / Hashnode
    participant AI as Anthropic Claude
    participant DB as Supabase DB

    Note over C,DB: 4:00 AM UTC â€” Archive job
    C->>DB: Move yesterday's quests â†’ archive table

    Note over C,DB: 5:01 AM UTC â€” Generation job
    C->>N: POST /scheduled-daily
    N->>N: Validate cron secret header
    N->>DB: Query: quests exist today?
    DB-->>N: No results

    par Fetch live signals
        N->>G: GET search/issues (pain-point phrases)
        G-->>N: Matching open issues
    and
        N->>A: GET dev.to/feed + hashnode/rss
        A-->>N: Recent article titles + URLs
    end

    N->>AI: POST /messages (5 quest prompt + signals)
    AI-->>N: 5 quest ideas (JSON)
    N->>N: enrichSources() â€” attach real signal URLs
    N->>DB: INSERT into daily_quests
    DB-->>N: 201 Created
      </div>
    </div>

    <div class="diagram-wrap">
      <div class="diagram-label">On-Demand "Let's Build!" Path</div>
      <div class="mermaid">
sequenceDiagram
    participant U as Browser
    participant N as Netlify Function
    participant Gem as Google Gemini

    U->>U: User clicks "Let's Build!"
    U->>U: Open modal (loading spinner)
    U->>N: POST /generatePrompt
    Note right of U: payload: title, murmur,<br/>quest, worth, difficulty

    N->>N: Validate API key + required fields
    N->>N: Build difficulty-adjusted prompt
    N->>Gem: POST /generateContent (45s timeout)

    alt Success
        Gem-->>N: Markdown build guide
        N->>N: Clean markdown formatting
        N-->>U: { prompt: "...markdown..." }
        U->>U: Convert markdown â†’ HTML
        U->>U: Display in modal with copy button
    else Rate limit or timeout
        Gem-->>N: 429 or timeout
        N-->>U: Error message
        U->>U: Display error in modal
    end
      </div>
    </div>

  </div>
</div>

<!-- BUILD PROMPT MODAL -->
<div class="modal" id="buildModal" style="display: none;">
  <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
    <div class="close-x" onclick="closeBuildModal()">âœ•</div>
    <h2 style="margin-top: 0;">ðŸš€ Let's Build This!</h2>
    <div id="modalPromptContent"></div>
  </div>
</div>

<script>
  let currentIdea = null;

  async function loadIdeas() {
    const res = await fetch("/.netlify/functions/latest");
    const data = await res.json();
    const container = document.getElementById("ideas");

    const ideas = Array.isArray(data)
      ? data
      : Array.isArray(data?.ideas)
        ? data.ideas
        : [];

    const banner = document.querySelector(".banner");
    if (banner) {
      banner.textContent = ideas.some(i => i.sources && i.sources.length)
        ? "Live editorial signals detected."
        : "Sample data mode â€” live signals unavailable.";
    }

    if (!ideas.length) {
      container.innerHTML = `
        <div class="quest">
          <h2>No signals available</h2>
          <div class="section">
            <div class="section-title">System Status</div>
            <div>Live sources responded, but no usable ideas were synthesized.</div>
          </div>
        </div>
      `;
      return;
    }
    
    container.innerHTML = ideas.map((q, idx) => {
      const sourcesHTML = (q.sources || []).map(s => {
        let iconHTML = '';
        if (s.type === 'github') {
          iconHTML = '<i data-lucide="github" style="width: 14px; height: 14px;"></i>';
        } else if (s.type === 'x' || s.type === 'twitter') {
          iconHTML = '<svg style="width: 14px; height: 14px; fill: currentColor;" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>';
        } else {
          iconHTML = '<i data-lucide="rss" style="width: 14px; height: 14px;"></i>';
        }
        
        return `<li style="margin-bottom: 0.3rem; display: flex; align-items: center; gap: 0.4rem;">
          ${iconHTML}
          <a href="${s.url}" target="_blank" style="color: var(--muted); text-decoration: none;">
            ${s.name}
          </a>
        </li>`;
      }).join("");

      return `
        <div class="quest">
          <h2>${q.title}</h2>

          <div class="section">
            <div class="section-title">ðŸ’¬ Murmur â†’ Why this exists</div>
            <div>${q.murmur}</div>
          </div>

          <div class="section">
            <div class="section-title">ðŸ§­ Side Quest â†’ What to build</div>
            <div>${q.quest}</div>
          </div>

          <div class="section">
            <div class="section-title">âœ¨ For What It's Worth â†’ Why it's worth your energy</div>
            <ul style="margin: 0.5rem 0 0 1.2rem; padding: 0;">
              ${(q.worth || []).map(w => `<li style="margin-bottom: 0.3rem;">${w}</li>`).join("")}
            </ul>
          </div>

          <div class="section">
            <div class="section-title">ðŸ§¾ Signals Observed â†’ Receipts, if you want them</div>
            <ul style="margin: 0.5rem 0 0 1.2rem; padding: 0; list-style: none;">
              ${sourcesHTML}
            </ul>
          </div>

          <div class="meta">
            <span class="difficulty ${q.difficulty.toLowerCase()}">${q.difficulty}</span>
            <button class="build-button" onclick="openBuildModal(${idx})" data-idea='${JSON.stringify(q).replace(/'/g, "&apos;")}'>
              <i data-lucide="wrench"></i> Let's Build!
            </button>
          </div>
        </div>
      `;
    }).join("");

    lucide.createIcons();
  }

  async function openBuildModal(ideaIndex) {
    const ideas = Array.from(document.querySelectorAll('.quest'));
    const ideaElement = ideas[ideaIndex];
    const button = ideaElement.querySelector('.build-button');
    const ideaData = JSON.parse(button.getAttribute('data-idea'));
    
    currentIdea = ideaData;
    
    const modal = document.getElementById('buildModal');
    const modalContent = document.getElementById('modalPromptContent');
    
    modal.style.display = 'flex';
    modalContent.innerHTML = '<div style="text-align: center; padding: 3rem;"><div class="loader"></div><p style="margin-top: 1rem; color: var(--muted);">Generating your project\'s AI prompt<br><span style="font-size: 0.85rem;">(may take 10-15 seconds to think)</span></p></div>';
    
    try {
      console.log('Calling generatePrompt with:', ideaData);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 45000); // 45 second timeout
      
      const response = await fetch('/.netlify/functions/generatePrompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(ideaData),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      console.log('Response status:', response.status);
      
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch (e) {
          const text = await response.text();
          console.error('Non-JSON error response:', text);
          throw new Error(`API returned ${response.status}: ${text.substring(0, 200)}`);
        }
        console.error('API Error Response:', errorData);
        throw new Error(errorData.error || `API returned ${response.status}`);
      }
      
      let data;
      try {
        const responseText = await response.text();
        console.log('Raw response (first 200 chars):', responseText.substring(0, 200));
        data = JSON.parse(responseText);
      } catch (e) {
        console.error('Failed to parse JSON:', e);
        throw new Error('Invalid JSON response from API');
      }
      
      if (!data.prompt) {
        console.error('No prompt in response:', data);
        throw new Error('API returned empty prompt');
      }
      
      console.log('Prompt generated successfully');
      
      // Convert markdown to HTML for better display
      const htmlContent = data.prompt
        .replace(/^# (.*$)/gim, '<h2 style="margin-top: 2rem; margin-bottom: 1rem;">$1</h2>')
        .replace(/^## (.*$)/gim, '<h3 style="margin-top: 1.5rem; margin-bottom: 0.8rem;">$1</h3>')
        .replace(/^### (.*$)/gim, '<h4 style="margin-top: 1rem; margin-bottom: 0.5rem;">$1</h4>')
        .replace(/^\* (.*$)/gim, '<li style="margin-bottom: 0.5rem;">$1</li>')
        .replace(/^- (.*$)/gim, '<li style="margin-bottom: 0.5rem;">$1</li>')
        .replace(/^(\d+)\. (.*$)/gim, '<li style="margin-bottom: 0.5rem;">$2</li>')
        .replace(/`([^`]+)`/g, '<code style="background: rgba(255,255,255,0.1); padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.9em;">$1</code>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\n\n/g, '</p><p style="margin-bottom: 1rem;">')
        .replace(/^(?!<[h|l|p])/gim, '<p style="margin-bottom: 1rem;">');
      
      modalContent.innerHTML = `
        <div style="margin-bottom: 1.5rem;">
          <button onclick="copyPrompt()" class="copy-button">
            <i data-lucide="copy"></i> Copy to Clipboard
          </button>
        </div>
        <div class="prompt-content">
          ${htmlContent}
        </div>
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
          <button onclick="copyPrompt()" class="copy-button">
            <i data-lucide="copy"></i> Copy to Clipboard
          </button>
        </div>
      `;
      
      lucide.createIcons();
      
    } catch (error) {
      console.error('Error generating prompt:', error);
      
      let errorMessage = error.message;
      if (error.name === 'AbortError') {
        errorMessage = 'Request timed out after 45 seconds. Please try again.';
      }
      
      modalContent.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: var(--muted);">
          <p>Oops! Something went wrong generating the prompt.</p>
          <p style="margin-top: 0.5rem; font-size: 0.85rem; color: #f87171;">${errorMessage}</p>
          <p style="margin-top: 1rem;">
            <button onclick="closeBuildModal()" style="padding: 0.5rem 1rem; background: var(--panel); border: 1px solid var(--border); color: var(--text); border-radius: 8px; cursor: pointer;">
              Close
            </button>
          </p>
        </div>
      `;
    }
  }

  function closeBuildModal() {
    document.getElementById('buildModal').style.display = 'none';
  }

  async function copyPrompt() {
    const promptContent = document.querySelector('.prompt-content');
    const textContent = promptContent.innerText;
    
    try {
      await navigator.clipboard.writeText(textContent);
      
      // Show feedback
      const copyButtons = document.querySelectorAll('.copy-button');
      copyButtons.forEach(btn => {
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<i data-lucide="check"></i> Copied!';
        btn.style.background = 'rgba(74, 222, 128, 0.2)';
        btn.style.borderColor = 'rgba(74, 222, 128, 0.5)';
        
        lucide.createIcons();
        
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.style.background = '';
          btn.style.borderColor = '';
          lucide.createIcons();
        }, 2000);
      });
    } catch (err) {
      console.error('Failed to copy:', err);
      alert('Failed to copy to clipboard. Please select and copy manually.');
    }
  }


  // Close modal when clicking outside
  window.onclick = function(event) {
    const modal = document.getElementById('buildModal');
    if (event.target === modal) {
      closeBuildModal();
    }
  }

  // Methodology modal
  let mermaidInitialized = false;
  mermaid.initialize({
    startOnLoad: false,
    theme: 'base',
    themeVariables: {
      primaryColor: '#1f2538', primaryTextColor: '#e8ebf3', primaryBorderColor: '#3d4a6b',
      lineColor: '#6b7a9e', secondaryColor: '#121622', tertiaryColor: '#0b0d12',
      background: '#0b0d12', mainBkg: '#1f2538', nodeBorder: '#3d4a6b',
      actorBkg: '#1a2035', actorBorder: '#3d4a6b', actorTextColor: '#e8ebf3',
      actorLineColor: '#3d4a6b', signalColor: '#6b7a9e', signalTextColor: '#cfd5e6',
      labelBoxBkgColor: '#121622', labelBoxBorderColor: '#3d4a6b', labelTextColor: '#cfd5e6',
      loopTextColor: '#cfd5e6', noteBorderColor: '#3d4a6b', noteBkgColor: '#1a2035',
      noteTextColor: '#cfd5e6', activationBorderColor: '#3d4a6b', activationBkgColor: '#262f4a',
      sequenceNumberColor: '#9aa3b2', edgeLabelBackground: '#1f2538', titleColor: '#e8ebf3'
    }
  });

  function toggleMethodology() {
    const m = document.getElementById('methodology');
    if (m.style.display === 'flex') {
      m.style.display = 'none';
    } else {
      m.style.display = 'flex';
      if (!mermaidInitialized) {
        mermaid.run({ nodes: document.querySelectorAll('#methodology .mermaid') });
        mermaidInitialized = true;
      }
    }
  }

  loadIdeas();
  lucide.createIcons();
</script>

</body>
</html>
